/*
TrueNAS RESTful API

Go SDK for interacting with TrueNAS APIs (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package truenas

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// DatasetAPIService DatasetAPI service
type DatasetAPIService service

type ApiCreateDatasetRequest struct {
	ctx                 context.Context
	ApiService          *DatasetAPIService
	createDatasetParams *CreateDatasetParams
}

func (r ApiCreateDatasetRequest) CreateDatasetParams(createDatasetParams CreateDatasetParams) ApiCreateDatasetRequest {
	r.createDatasetParams = &createDatasetParams
	return r
}

func (r ApiCreateDatasetRequest) Execute() (*Dataset, *http.Response, error) {
	return r.ApiService.CreateDatasetExecute(r)
}

/*
CreateDataset Method for CreateDataset

Creates a dataset/zvol.

`volsize` is required for type=VOLUME and is supposed to be a multiple of the block size.
`sparse` and `volblocksize` are only used for type=VOLUME.

`encryption` when enabled will create an ZFS encrypted root dataset for `name` pool.
There are 2 cases where ZFS encryption is not allowed for a dataset:
 1. Pool in question is GELI encrypted.
 2. If the parent dataset is encrypted with a passphrase and `name` is being created
    with a key for encrypting the dataset.

`encryption_options` specifies configuration for encryption of dataset for `name` pool.
`encryption_options.passphrase` must be specified if encryption for dataset is desired with a passphrase
as a key.
Otherwise a hex encoded key can be specified by providing `encryption_options.key`.
`encryption_options.generate_key` when enabled automatically generates the key to be used
for dataset encryption.

It should be noted that keys are stored by the system for automatic locking/unlocking
on import/export of encrypted datasets. If that is not desired, dataset should be created
with a passphrase as a key.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateDatasetRequest
*/
func (a *DatasetAPIService) CreateDataset(ctx context.Context) ApiCreateDatasetRequest {
	return ApiCreateDatasetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Dataset
func (a *DatasetAPIService) CreateDatasetExecute(r ApiCreateDatasetRequest) (*Dataset, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Dataset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatasetAPIService.CreateDataset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createDatasetParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDatasetRequest struct {
	ctx        context.Context
	ApiService *DatasetAPIService
	id         string
}

func (r ApiDeleteDatasetRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDatasetExecute(r)
}

/*
DeleteDataset Method for DeleteDataset

Delete dataset/zvol

`recursive` will also delete/destroy all children datasets.
`force` will force delete busy datasets.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiDeleteDatasetRequest
*/
func (a *DatasetAPIService) DeleteDataset(ctx context.Context, id string) ApiDeleteDatasetRequest {
	return ApiDeleteDatasetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *DatasetAPIService) DeleteDatasetExecute(r ApiDeleteDatasetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatasetAPIService.DeleteDataset")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDatasetRequest struct {
	ctx        context.Context
	ApiService *DatasetAPIService
	id         string
	limit      *int32
	offset     *int32
	count      *bool
	sort       *string
}

func (r ApiGetDatasetRequest) Limit(limit int32) ApiGetDatasetRequest {
	r.limit = &limit
	return r
}

func (r ApiGetDatasetRequest) Offset(offset int32) ApiGetDatasetRequest {
	r.offset = &offset
	return r
}

func (r ApiGetDatasetRequest) Count(count bool) ApiGetDatasetRequest {
	r.count = &count
	return r
}

func (r ApiGetDatasetRequest) Sort(sort string) ApiGetDatasetRequest {
	r.sort = &sort
	return r
}

func (r ApiGetDatasetRequest) Execute() (*Dataset, *http.Response, error) {
	return r.ApiService.GetDatasetExecute(r)
}

/*
GetDataset Method for GetDataset

Query Pool Datasets with `query-filters` and `query-options`.

We provide two ways to retrieve datasets. The first is a flat structure (default), where
all datasets in the system are returned as separate objects which contain all data
there is for their children. This retrieval type is slightly slower because of duplicates in each object.
The second type is hierarchical, where only top level datasets are returned in the list. They contain all the
children in the `children` key. This retrieval type is slightly faster.
These options are controlled by the `query-options.extra.flat` attribute (default true).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID of the dataset
	@return ApiGetDatasetRequest
*/
func (a *DatasetAPIService) GetDataset(ctx context.Context, id string) ApiGetDatasetRequest {
	return ApiGetDatasetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Dataset
func (a *DatasetAPIService) GetDatasetExecute(r ApiGetDatasetRequest) (*Dataset, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Dataset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatasetAPIService.GetDataset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDatasetsRequest struct {
	ctx        context.Context
	ApiService *DatasetAPIService
	limit      *int32
	offset     *int32
	count      *bool
	sort       *string
}

func (r ApiListDatasetsRequest) Limit(limit int32) ApiListDatasetsRequest {
	r.limit = &limit
	return r
}

func (r ApiListDatasetsRequest) Offset(offset int32) ApiListDatasetsRequest {
	r.offset = &offset
	return r
}

func (r ApiListDatasetsRequest) Count(count bool) ApiListDatasetsRequest {
	r.count = &count
	return r
}

func (r ApiListDatasetsRequest) Sort(sort string) ApiListDatasetsRequest {
	r.sort = &sort
	return r
}

func (r ApiListDatasetsRequest) Execute() ([]Dataset, *http.Response, error) {
	return r.ApiService.ListDatasetsExecute(r)
}

/*
ListDatasets Method for ListDatasets

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListDatasetsRequest
*/
func (a *DatasetAPIService) ListDatasets(ctx context.Context) ApiListDatasetsRequest {
	return ApiListDatasetsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Dataset
func (a *DatasetAPIService) ListDatasetsExecute(r ApiListDatasetsRequest) ([]Dataset, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Dataset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatasetAPIService.ListDatasets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDatasetRequest struct {
	ctx                 context.Context
	ApiService          *DatasetAPIService
	id                  string
	updateDatasetParams *UpdateDatasetParams
}

func (r ApiUpdateDatasetRequest) UpdateDatasetParams(updateDatasetParams UpdateDatasetParams) ApiUpdateDatasetRequest {
	r.updateDatasetParams = &updateDatasetParams
	return r
}

func (r ApiUpdateDatasetRequest) Execute() (*Dataset, *http.Response, error) {
	return r.ApiService.UpdateDatasetExecute(r)
}

/*
UpdateDataset Method for UpdateDataset

Update dataset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiUpdateDatasetRequest
*/
func (a *DatasetAPIService) UpdateDataset(ctx context.Context, id string) ApiUpdateDatasetRequest {
	return ApiUpdateDatasetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Dataset
func (a *DatasetAPIService) UpdateDatasetExecute(r ApiUpdateDatasetRequest) (*Dataset, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Dataset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatasetAPIService.UpdateDataset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDatasetParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
